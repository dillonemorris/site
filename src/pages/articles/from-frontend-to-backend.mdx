import { ArticleLayout } from '@/components/ArticleLayout'

export const meta = {
  author: 'Dillon Morris',
    // TODO: Update date
  date: '2023-05-06',
  title: 'From Frontend to Backend: Building a Full-Stack React App with Apollo and GraphQL',
  description:
    "In this post we'll write a basic CRUD API using Apollo and GraphQL and connect it to a React frontend.",
}

export default (props) => <ArticleLayout meta={meta} {...props} />

This post will cover writing a basic CRUD API using Apollo and GraphQL and connecting it to a React frontend. This will be relevant to web developers who want to learn how to create a full-stack application using modern technologies. By using Apollo and GraphQL, we can create APIs that are efficient, flexible, and easy to maintain. In this blog post, we'll walk through the steps of building a basic CRUD API using Apollo and GraphQL, and show how to connect it to a React frontend.

## What is GraphQL?

GraphQL is a programming language and execution engine that was created by Facebook to simplify the process of requesting data from servers to clients by providing a more efficient, powerful, and adaptable option to REST APIs. REST APIs (Representational State Transfer APIs) are a set of guidelines and architectural principles for constructing web services that utilize HTTP as the underlying communication protocol.

REST and GraphQL are both API architectural patterns used for building web applications, but they have some differences:

1. Data fetching: REST APIs use multiple endpoints to fetch different types of data, while GraphQL APIs use a single endpoint to retrieve all the requested data in one go.
2. Data shape: REST APIs have a fixed data shape and return all the fields defined in the server, while GraphQL APIs allow clients to specify the data shape they want to receive, which can improve performance and reduce overfetching and underfetching.
3. Caching: REST APIs rely on HTTP caching mechanisms to improve performance, while GraphQL APIs have a built-in caching mechanism that caches the responses at the field-level, which provides more granular caching control.
4. Versioning: REST APIs often require versioning to manage changes to the API, while GraphQL APIs can add new fields without affecting existing queries and clients.

In general, GraphQL offers greater adaptability and efficiency in data retrieval, whereas REST provides a well-established and commonly used architectural design with strong tooling support. The decision between GraphQL and REST ultimately hinges on the specific requirements of the project, but GraphQL's benefits in terms of adaptability, efficiency, and developer efficiency are contributing to its growing popularity as a preferred option for creating modern APIs.


## Setting up the backend

So we’ve learned about what GraphQL is and why we’d want to use it, now, let’s dive in to creating our backend. In the spirit of “schema-first development” it’s only fitting that we start by writing the schema for our GraphQL API. In the remainder of this section, we’ll define the types, queries, and mutations that our API will support.

We can define our schema using the GraphQL Schema Definition Language (SDL), which is a simple syntax for defining GraphQL schemas.

Note: Since our primary goal is to learn how to set up a GraphQL backend, rather than create a complex or revolutionary application, we’re going to develop a simple note-taking app. Let’s create our first type, which will be the note type:

```graphql
type Note {
  id: ID!
  title: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}
```

This schema defines a Note type with fields for id, title, content, createdAt, and updatedAt. As you can see, we’re assigning our GraphQL schema to a constant called typeDefs and using the gql tagged template literal.

Okay, so we have our Note type, which is the backbone of our GraphQL schema. Next, we’ll want to create a Query type. The shape of this schema will hopefully make more sense when we move onto the next section concerning resolvers, but for now, let’s copy/paste the following Query type into our schema definition:

```graphql
type Note {
  id: ID!
  title: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Query {
  notes: [Note!]!
  noteById(id: ID!): Note
}
```

The Query type has two fields: notes, which returns a list of all notes, and noteById, which returns a single note by its id. In the next section, we’ll write resolvers (link) for each of the fields in this schema. Before we move on to resolvers, let’s include a Mutation type:

```graphql
type Note {
  id: ID!
  title: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Query {
  notes: [Note!]!
  noteById(id: ID!): Note
}

type Mutation {
  createNote(
    title: String!,
    content: String!
  ): Note!

  updateNote(
    id: ID!,
    title: String!,
    content: String!
  ): Note!

  deleteNote(
    id: ID!
  ): Boolean!
}
```

The Mutation type has three fields for creating, updating, and deleting notes. createNote takes a title and content argument and returns the newly created note. updateNote takes an id, title, and content argument and returns the updated note. deleteNote takes an id argument and returns a boolean indicating whether the note was successfully deleted.

Now that we have our schema in place, we can write the corresponding resolvers. First, let’s learn more about what resolvers are and what they do.

### Resolvers

Resolvers in GraphQL are functions that resolve the data that corresponds to a specific field in a GraphQL schema. In other words, they are the functions that are responsible for fetching the data for a particular field in a GraphQL query. The resolver receives arguments, such as the parent object and any variables passed in the query, and returns the resolved data for that field. They can also interact with external data sources or APIs to retrieve the data needed. The main purpose of resolvers is to provide flexibility in data fetching, allowing developers to retrieve data from multiple sources and manipulate it in various ways before returning it to the client.

```js
const notes = [
  {
    id: "1",
    title: "First Note",
    content: "This is the first note.",
    createdAt: new Date("2022-01-01T00:00:00Z"),
    updatedAt: new Date("2022-01-01T00:00:00Z"),
  },
  {
    id: "2",
    title: "Second Note",
    content: "This is the second note.",
    createdAt: new Date("2022-01-02T00:00:00Z"),
    updatedAt: new Date("2022-01-02T00:00:00Z"),
  },
];

const resolvers = {
  Query: {
    notes: () => notes,
    noteById: (_, { id }) => notes.find(note => note.id === id),
  },
};
```







